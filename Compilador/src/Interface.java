

import java.io.*;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFileChooser;

import java_cup.runtime.Symbol;


public class Interface extends javax.swing.JFrame {

    /**
     * Creates new form Interface
     */
    public Interface() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
    
        // Inicialización de componentes
        btnAnalizar = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        jScrollPane2 = new javax.swing.JScrollPane();
        jScrollPane3 = new javax.swing.JScrollPane();
        jScrollPane4 = new javax.swing.JScrollPane();
        txtResultado = new javax.swing.JTextArea();
        txtErroresLexicos = new javax.swing.JTextArea();
        txtErroresSintaxis = new javax.swing.JTextArea();
        txtErroresSemanticos = new javax.swing.JTextArea();
        txtTablaSimbolos = new javax.swing.JTextArea();


        
        // Inicialización de etiquetas
        lblResultado = new javax.swing.JLabel();
        lblErroresLexicos = new javax.swing.JLabel();
        lblErroresSintaxis = new javax.swing.JLabel();
        lblErroresSemanticos = new javax.swing.JLabel();
        lblTablaSimbolos = new javax.swing.JLabel();

    
        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
    
        // Configuración del botón "Analizar"
        btnAnalizar.setFont(new java.awt.Font("Segoe UI", 0, 24)); // NOI18N
        btnAnalizar.setText("Analizar");
        btnAnalizar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnAnalizarActionPerformed(evt);
            }
        });
        /*
        // Configuración del área de texto para "Resultado"
        txtResultado.setColumns(20);
        txtResultado.setRows(5);
        txtResultado.setFont(new java.awt.Font("Segoe UI", 0, 14)); // Aumentar tamaño de letra
        jScrollPane1.setViewportView(txtResultado);
        */

        // Configuración del área de texto para "Errores Léxicos"
        txtErroresLexicos.setColumns(20);
        txtErroresLexicos.setRows(5);
        txtErroresLexicos.setFont(new java.awt.Font("Segoe UI", 0, 14)); // Aumentar tamaño de letra
        jScrollPane1.setViewportView(txtErroresLexicos);
    
        // Configuración del área de texto para "Errores de Sintaxis"
        txtErroresSintaxis.setColumns(20);
        txtErroresSintaxis.setRows(5);
        txtErroresSintaxis.setFont(new java.awt.Font("Segoe UI", 0, 15)); // Aumentar tamaño de letra
        jScrollPane2.setViewportView(txtErroresSintaxis);

        // Configuración del área de texto para "Errores Semanticos"
        txtErroresSemanticos.setColumns(20);
        txtErroresSemanticos.setRows(5);
        txtErroresSemanticos.setFont(new java.awt.Font("Segoe UI", 0, 15)); // Aumentar tamaño de letra
        jScrollPane3.setViewportView(txtErroresSemanticos);

        // Configuración del área de texto para "Tabla de Simbolos"
        txtTablaSimbolos.setColumns(20);
        txtTablaSimbolos.setRows(5);
        txtTablaSimbolos.setFont(new java.awt.Font("Segoe UI", 0, 15)); // Aumentar tamaño de letra
        jScrollPane4.setViewportView(txtTablaSimbolos);

        
    
        // Configuración de las etiquetas
        lblResultado.setFont(new java.awt.Font("Segoe UI", 0, 18)); // NOI18N
        lblResultado.setText("Tokens:");
    
        lblErroresLexicos.setFont(new java.awt.Font("Segoe UI", 0, 18)); // NOI18N
        lblErroresLexicos.setText("Errores Léxicos:");
    
        lblErroresSintaxis.setFont(new java.awt.Font("Segoe UI", 0, 18)); // NOI18N
        lblErroresSintaxis.setText("Errores de Sintaxis:");

        lblErroresSemanticos.setFont(new java.awt.Font("Segoe UI", 0, 18)); // NOI18N
        lblErroresSemanticos.setText("Errores de Semántica:");

        lblTablaSimbolos.setFont(new java.awt.Font("Segoe UI", 0, 18)); // NOI18N
        lblTablaSimbolos.setText("Tabla de Simbolos:");
    
        // Definición del layout del contenido
        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(btnAnalizar, javax.swing.GroupLayout.DEFAULT_SIZE, 600, Short.MAX_VALUE) // Ancho ajustado aquí
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(lblErroresLexicos)
                            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 290, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(lblErroresSintaxis)
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 290, Short.MAX_VALUE))))
            .addContainerGap())
            .addGroup(layout.createSequentialGroup()
            .addContainerGap()
            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(layout.createSequentialGroup()
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addComponent(lblErroresSemanticos)
                        .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 290, Short.MAX_VALUE))
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addComponent(lblTablaSimbolos)
                        .addComponent(jScrollPane4, javax.swing.GroupLayout.DEFAULT_SIZE, 290, Short.MAX_VALUE))))
            .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(btnAnalizar)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lblErroresLexicos)
                    .addComponent(lblErroresSintaxis))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 150, Short.MAX_VALUE)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 150, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lblErroresSemanticos)
                    .addComponent(lblTablaSimbolos))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 150, Short.MAX_VALUE)
                    .addComponent(jScrollPane4, javax.swing.GroupLayout.DEFAULT_SIZE, 150, Short.MAX_VALUE))                
                .addContainerGap())
        );
    
        // Definir el tamaño preferido del JFrame
        setPreferredSize(new java.awt.Dimension(800, 700)); 
        pack(); // Ajusta la ventana al contenido
    }// </editor-fold>//GEN-END:initComponents
    
    


    private void btnAnalizarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnAnalizarActionPerformed
        JFileChooser chooser = new JFileChooser();
        chooser.showOpenDialog(null);
        java.io.File file = chooser.getSelectedFile();
        String fileName = file.getName();

        try{
            String content = new String(Files.readAllBytes(file.toPath()));   
            analizadorLexico(content);  
            analizadorSintactico(content, fileName);

        } catch (FileNotFoundException ex) {
            Logger.getLogger(Interface.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            Logger.getLogger(Interface.class.getName()).log(Level.SEVERE, null, ex);
        }

    }//GEN-LAST:event_btnAnalizarActionPerformed

    private void analizadorLexico(String content){
        int line = 1;
        try {
            //guardar la cantidad de apariciones
            Map<String, List<Integer>> apariciones = new LinkedHashMap<>();
            Lexer lexer = new Lexer(new StringReader(content));
            String resultado = "";
            String errores = "";
            while(true){
                Tokens tokens = lexer.yylex();
                line = lexer.getLineNumber();
                System.out.println("{Token: " + lexer.lexeme + " } {Typo: " + tokens +  "} {Linea: " + line + "}");

                if (tokens == null){
                    for (Map.Entry<String, List<Integer>> entry : apariciones.entrySet()) {
                        StringBuilder cantApariciones = new StringBuilder();
                        // contar la cantidad de apariciones que tiene en una linea
                        Map<Integer, Integer> ocurrencias = new HashMap<>();
                        for (int aparicion : entry.getValue()) {
                            ocurrencias.put(aparicion, ocurrencias.getOrDefault(aparicion, 0) + 1);
                        }
                        for (Map.Entry<Integer, Integer> ocur : ocurrencias.entrySet()) {
                            int numLinea = ocur.getKey();
                            int cuenta = ocur.getValue();

                            // agregar comas si siguen mas numeros 
                            if (cantApariciones.length() > 0) {
                                cantApariciones.append(", ");
                            }
            
                            if (cuenta > 1) {
                                cantApariciones.append(numLinea).append("(").append(cuenta).append(")");
                            } else {
                                cantApariciones.append(numLinea);
                            }
                        }
            
                        resultado += entry.getKey() + " {Linea: " + cantApariciones.toString() + "}\n";
                    }
            
                    resultado += "FIN";
                    txtResultado.setText(resultado);

                    errores += "FIN";
                    txtErroresLexicos.setText(errores);
                    return;
                }
                switch (tokens) {
                    case ERROR:
                        errores += "Error: " + "{Token: " + lexer.lexeme + " }" + " {Linea: " + line + "}\n";
                        break;
                    case Reservadas: 
                    case Operadores: 
                    case Identificadores: 
                    case Strings:
                    case Caracteres:
                    case CaracteresNumericos:
                    case Decimales:
                    case Octales: 
                    case Hexadecimales:
                    case Flotantes:
                    case FlotantesExpenciales:
                        String token = "{Token: " + lexer.lexeme + " } {Tipo: " + tokens +  "}";
                        apariciones.putIfAbsent(token, new ArrayList<>());
                        apariciones.get(token).add(line);
                        break;
                    default:
                        resultado += "Token: " + tokens + "\n";
                        break;
                }switch (tokens) {
                    case ERROR:
                        errores += "Error: " + "{Token: " + lexer.lexeme + " }" + " {Linea: " + line + "}\n";
                        break;
                    case ERROR_STRING_NO_CERRADO:
                        errores += "ERROR_STRING_NO_CERRADO: " + "{Token: " + lexer.lexeme + " }" + " {Linea: " + line + "}\n";
                        break;
                    case ERROR_IDENTIFICADOR_INVALIDO:
                        errores += "ERROR_IDENTIFICADOR_INVALIDO: " + "{Token: " + lexer.lexeme + " }" + " {Linea: " + line + "}\n";
                        break;
                    case ERROR_SALTO_LINEA:
                        errores += "ERROR_SALTO_LINEA: " + "{Token: " + lexer.lexeme + " }" + " {Linea: " + line + "}\n";
                        break;
                    case ERROR_NUMERO_MAL_FORMADO:
                        errores += "ERROR_NUMERO_MAL_FORMADO: " + "{Token: " + lexer.lexeme + " }" + " {Linea: " + line + "}\n";
                        break;
                    case ERROR_COMENTARIO_NO_CERRADO:
                        errores += "ERROR_COMENTARIO_NO_CERRADO: " + "{Token: " + lexer.lexeme + " }" + " {Linea: " + line + "}\n";
                        break;
                    case ERROR_CARACTER_NO_CERRADO:
                        errores += "ERROR_CARACTER_NO_CERRADO: " + "{Token: " + lexer.lexeme + " }" + " {Linea: " + line + "}\n";
                        break;
                    case ERROR_CARACTER_MAL_FORMADO:
                        errores += "ERROR_CARACTER_MAL_FORMADO: " + "{Token: " + lexer.lexeme + " }" + " {Linea: " + line + "}\n";
                        break;
                    case Reservadas: 
                    case Operadores: 
                    case Identificadores: 
                    case Strings:
                    case Caracteres:
                    case CaracteresNumericos:
                    case Decimales:
                    case Octales: 
                    case Hexadecimales:
                    case Flotantes:
                    case FlotantesExpenciales:
                        String token = "{Token: " + lexer.lexeme + " } {Tipo: " + tokens +  "}";
                        apariciones.putIfAbsent(token, new ArrayList<>());
                        apariciones.get(token).add(line);
                        break;
                    default:
                        resultado += "Token: " + tokens + "\n";
                        break;
                }
            }
        } catch (FileNotFoundException ex) {
            Logger.getLogger(Interface.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            Logger.getLogger(Interface.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    private void analizadorSintactico(String content, String fileName){
        Sintax s = new Sintax(new LexerCup (new StringReader(content)));
        
        try {
            s.parse();
            txtErroresSintaxis.setText(s.getErrorMessage());
            txtErroresSemanticos.setText(s.getSemanErrors());
            txtTablaSimbolos.setText(s.getTablaSimbolos());
            //s.getPilaSemantica().print();
            
            System.out.println("\n Traduccion: " + s.getTraduccion());
            
            // Generar el nombre del archivo .asm basado en el nombre del archivo fuente
            String asmFileName = fileName.replaceAll("\\.[^.]+$", "") + ".asm";

            // Escribir la traducción en el archivo .asm
            try (FileWriter writer = new FileWriter(asmFileName)) {
                writer.write(s.getTraduccion());
            }

            System.out.println("Traducción escrita en el archivo: " + asmFileName);
        
        } catch (Exception e) {
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Interface.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Interface.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Interface.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Interface.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Interface().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnAnalizar;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JTextArea txtResultado;
    private javax.swing.JTextArea txtErroresLexicos;
    private javax.swing.JTextArea txtErroresSintaxis;
    private javax.swing.JTextArea txtErroresSemanticos;
    private javax.swing.JTextArea txtTablaSimbolos;

    private javax.swing.JLabel lblResultado;
    private javax.swing.JLabel lblErroresLexicos;
    private javax.swing.JLabel lblErroresSintaxis;
    private javax.swing.JLabel lblErroresSemanticos;
    private javax.swing.JLabel lblTablaSimbolos;



    

    // End of variables declaration//GEN-END:variables
}